/*
 * Copyright 2006 Helsinki Institute for Information Technology
 *
 * This file is a part of Fuego middleware.  Fuego middleware is free
 * software; you can redistribute it and/or modify it under the terms
 * of the MIT license, included as the file MIT-LICENSE in the Fuego
 * middleware source distribution.  If you did not receive the MIT
 * license with the distribution, write to the Fuego Core project at
 * fuego-core-users@hoslab.cs.helsinki.fi.
 */

package fuegocore.util.xas;

import java.io.OutputStream;
import java.io.Writer;
import java.io.IOException;

import org.xmlpull.v1.XmlSerializer;

import fuegocore.util.Util;

/**
 * A class to branch XML to two different processors.  An XmlTee
 * object is a {@link TypedXmlSerializer} that knows of two other
 * {@link TypedXmlSerializer} objects.  Whenever an event is
 * communicated to the XmlTee object, it passes the event to both
 * component serializers.
 *
 * <p>The main purpose of the XmlTee class is to assist in debugging
 * when programmatically creating XML with the XAS interface.  In this
 * case it is possible to replace the normal serializer with an XmlTee
 * object that passes the events both to the original serializer and
 * some other serializer that e.g. logs all the XML into a file.
 *
 * <p>No guarantees are made as to the order in which the two
 * serializers receive the XAS events.  It is even possible that this
 * happens in parallel.  Exceptions generated by the serializers are
 * thrown either directly, or, when both calls throw, through the use
 * of a TeeException wrapped as the cause of the thrown exception.
 */
public class XmlTee implements TypedXmlSerializer {

    private TypedXmlSerializer left;
    private TypedXmlSerializer right;

    /**
     * A TeeException object contains two exceptions.  When branching
     * the execution into two independent branches, it is necessary to
     * communicate the exceptions thrown in both branches.  A
     * TeeException object encapsulates two different exceptions with
     * access methods for them.
     */
    public static class TeeException extends Exception {

	private Exception left;
	private Exception right;

	/**
	 * Constructor for TeeExceptions.  It is allowed for one or
	 * both of the component exceptions to be <code>null</code>.
	 *
	 * @param left the exception from the left branch
	 * @param right the exception from the right branch
	 */
	public TeeException (Exception left, Exception right) {
	    this.left = left;
	    this.right = right;
	}

	public Exception getLeft () {
	    return left;
	}

	public Exception getRight () {
	    return right;
	}

    }

    private void throwIfNeeded (IOException lex, IOException rex)
	throws IOException {
	if (lex != null) {
	    if (rex != null) {
		IOException ex = new IOException();
		ex.initCause(new TeeException(lex, rex));
		throw ex;
	    } else {
		throw lex;
	    }
	} else if (rex != null) {
	    throw rex;
	}
    }

    /**
     * Constructor for XmlTee objects.  The order of the component
     * serializers is meaningful only when exceptions are reported on
     * both branches, in which case the one from <code>left</code> is
     * also the left of the thrown TeeException.
     *
     * @param left the serializer on the left
     * @param right the serializer on the right
     *
     * @throws NullPointerException if either component serializer is
     * <code>null</code>
     */
    public XmlTee (TypedXmlSerializer left, TypedXmlSerializer right) {
	if (left == null || right == null) {
	    throw new NullPointerException("XmlTee requires non-null "
					   + "serializers");
	}
	this.left = left;
	this.right = right;
    }

    public void setFeature (String name, boolean state) {
    }

    public boolean getFeature (String name) {
	return false;
    }

    public void setProperty (String name, Object value) {
    }

    public Object getProperty (String name) {
	return null;
    }

    public void setOutput (OutputStream os, String encoding) {
    }

    public void setOutput (Writer writer) {
    }

    public void startDocument (String encoding, Boolean standalone)
	throws IOException {
	IOException lex = null, rex = null;
	try {
	    left.startDocument(encoding, standalone);
	} catch (IOException ex) {
	    lex = ex;
	}
	try {
	    right.startDocument(encoding, standalone);
	} catch (IOException ex) {
	    rex = ex;
	}
	throwIfNeeded(lex, rex);
    }

    public void endDocument () throws IOException {
	IOException lex = null, rex = null;
	try {
	    left.endDocument();
	} catch (IOException ex) {
	    lex = ex;
	}
	try {
	    right.endDocument();
	} catch (IOException ex) {
	    rex = ex;
	}
	throwIfNeeded(lex, rex);
    }

    public void setPrefix (String prefix, String namespace)
	throws IOException {
	IOException lex = null, rex = null;
	try {
	    left.setPrefix(prefix, namespace);
	} catch (IOException ex) {
	    lex = ex;
	}
	try {
	    right.setPrefix(prefix, namespace);
	} catch (IOException ex) {
	    rex = ex;
	}
	throwIfNeeded(lex, rex);
    }

    public String getPrefix (String namespace, boolean generatePrefix) {
	String p = null;
	if (!generatePrefix) {
	    String lp = left.getPrefix(namespace, generatePrefix);
	    String rp = right.getPrefix(namespace, generatePrefix);
	    if (Util.equals(lp, rp)) {
		p = lp;
	    }
	}
	return p;
    }

    public int getDepth () {
	int d = -1;
	int ld = left.getDepth();
	int rd = right.getDepth();
	if (ld == rd) {
	    d = ld;
	}
	return d;
    }

    public String getNamespace () {
	String n = null;
	String ln = left.getNamespace();
	String rn = right.getNamespace();
	if (Util.equals(ln, rn)) {
	    n = ln;
	}
	return n;
    }

    public String getName () {
	String n = null;
	String ln = left.getName();
	String rn = right.getName();
	if (Util.equals(ln, rn)) {
	    n = ln;
	}
	return n;
    }

    public XmlSerializer startTag (String namespace, String name)
	throws IOException {
	IOException lex = null, rex = null;
	try {
	    left.startTag(namespace, name);
	} catch (IOException ex) {
	    lex = ex;
	}
	try {
	    right.startTag(namespace, name);
	} catch (IOException ex) {
	    rex = ex;
	}
	throwIfNeeded(lex, rex);
	return this;
    }

    public XmlSerializer attribute (String namespace, String name,
				    String value)
	throws IOException {
	IOException lex = null, rex = null;
	try {
	    left.attribute(namespace, name, value);
	} catch (IOException ex) {
	    lex = ex;
	}
	try {
	    right.attribute(namespace, name, value);
	} catch (IOException ex) {
	    rex = ex;
	}
	throwIfNeeded(lex, rex);
	return this;
    }

    public XmlSerializer endTag (String namespace, String name)
	throws IOException {
	IOException lex = null, rex = null;
	try {
	    left.endTag(namespace, name);
	} catch (IOException ex) {
	    lex = ex;
	}
	try {
	    right.endTag(namespace, name);
	} catch (IOException ex) {
	    rex = ex;
	}
	throwIfNeeded(lex, rex);
	return this;
    }

    public XmlSerializer text (String text) throws IOException {
	IOException lex = null, rex = null;
	try {
	    left.text(text);
	} catch (IOException ex) {
	    lex = ex;
	}
	try {
	    right.text(text);
	} catch (IOException ex) {
	    rex = ex;
	}
	throwIfNeeded(lex, rex);
	return this;
    }

    public XmlSerializer text (char[] buf, int start, int len)
	throws IOException {
	IOException lex = null, rex = null;
	try {
	    left.text(buf, start, len);
	} catch (IOException ex) {
	    lex = ex;
	}
	try {
	    right.text(buf, start, len);
	} catch (IOException ex) {
	    rex = ex;
	}
	throwIfNeeded(lex, rex);
	return this;
    }

    public TypedXmlSerializer typedContent (Object content, String namespace,
					    String name)
	throws IOException {
	IOException lex = null, rex = null;
	try {
	    left.typedContent(content, namespace, name);
	} catch (IOException ex) {
	    lex = ex;
	}
	try {
	    right.typedContent(content, namespace, name);
	} catch (IOException ex) {
	    rex = ex;
	}
	throwIfNeeded(lex, rex);
	return this;
    }

    public void cdsect (String text) throws IOException {
	IOException lex = null, rex = null;
	try {
	    left.cdsect(text);
	} catch (IOException ex) {
	    lex = ex;
	}
	try {
	    right.cdsect(text);
	} catch (IOException ex) {
	    rex = ex;
	}
	throwIfNeeded(lex, rex);
    }

    public void entityRef (String text) throws IOException {
	IOException lex = null, rex = null;
	try {
	    left.entityRef(text);
	} catch (IOException ex) {
	    lex = ex;
	}
	try {
	    right.entityRef(text);
	} catch (IOException ex) {
	    rex = ex;
	}
	throwIfNeeded(lex, rex);
    }

    public void processingInstruction (String text) throws IOException {
	IOException lex = null, rex = null;
	try {
	    left.processingInstruction(text);
	} catch (IOException ex) {
	    lex = ex;
	}
	try {
	    right.processingInstruction(text);
	} catch (IOException ex) {
	    rex = ex;
	}
	throwIfNeeded(lex, rex);
    }

    public void comment (String text) throws IOException {
	IOException lex = null, rex = null;
	try {
	    left.comment(text);
	} catch (IOException ex) {
	    lex = ex;
	}
	try {
	    right.comment(text);
	} catch (IOException ex) {
	    rex = ex;
	}
	throwIfNeeded(lex, rex);
    }

    public void docdecl (String text) throws IOException {
	IOException lex = null, rex = null;
	try {
	    left.docdecl(text);
	} catch (IOException ex) {
	    lex = ex;
	}
	try {
	    right.docdecl(text);
	} catch (IOException ex) {
	    rex = ex;
	}
	throwIfNeeded(lex, rex);
    }

    public void ignorableWhitespace (String text) throws IOException {
	IOException lex = null, rex = null;
	try {
	    left.ignorableWhitespace(text);
	} catch (IOException ex) {
	    lex = ex;
	}
	try {
	    right.ignorableWhitespace(text);
	} catch (IOException ex) {
	    rex = ex;
	}
	throwIfNeeded(lex, rex);
    }

    public void flush () throws IOException {
	IOException lex = null, rex = null;
	try {
	    left.flush();
	} catch (IOException ex) {
	    lex = ex;
	}
	try {
	    right.flush();
	} catch (IOException ex) {
	    rex = ex;
	}
	throwIfNeeded(lex, rex);
    }

}

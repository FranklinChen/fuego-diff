\documentclass[draft]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyphenat}
\usepackage{acronym}
\usepackage{url}

\title{The XAS API and the Xebu serialization format}
\author{Jaakko Kangasharju <jkangash@hiit.fi>}

\acrodef{ORL}{Object Representation Language}

\begin{document}

\maketitle

\section{Introduction}

This document provides an overview of the XAS API for XML processing
and the Xebu serialization format for XML data.  These components have
been implemented in the Fuego Core project at the Helsinki Institute
for Information Technology.  The purpose of Fuego Core is to address
issues relating to middleware for the future mobile wireless Internet,
and XAS and Xebu are a part of the XML-based messaging system of the
middleware platform implemented in the project.

All of the code and associated documentation is released under the MIT
license, a copy of which is contained in the distribution as well as
reproduced as appendix~\ref{app:mit-license} of this document.

\section{Structure of the Distribution}
\label{sec:structure}

The distribution has three sub-directories.  The \path{docs} directory
contains only this document.  The \path{utils} directory contains
scripts that run a Java Virtual Machine with all the needed classes
found.  To use the \path{utils/java} script, either run it from the
\path{code} directory of the distribution or set the environment
variable \path{FUEGOCORE_CODE} to the \path{code} directory.

The \path{code} directory contains all the code of the system.  The
\path{sh} subdirectory contains a simple script to produce Xebu format
data from XML.  This does not currently support using the schema-based
optimizations of Xebu.

The main code is in the \path{java} subdirectory.  An Ant build file
is provided, so just running \path{ant} in the \path{java} directory
will build all the Java code.  The \path{README} file as well as the
comments in the \path{build.xml} file give information on available
targets.

The code generators are in the \path{sml} directory, and are
implemented in Standard ML.  Building them requires the MLton
compiler, and is accomplished by running \path{make} in the \path{sml}
directory.  A rudimentary regression test is available with \path{make
  check}.  Example files for the programs are available in the
\path{message/data} directory.

\section{The XAS API}
\label{sec:xas-api}

The XAS API at its core provides a low-level view of XML data, and
builds on top of this more sophisticated ways of handling XML.  The
XAS API is implemented in the package \path{fuegocore.util.xas} and
its possible subpackages.

The XAS API views an XML document as consisting of a sequence of
events, similarly to the XmlPull API (\url{http://www.xmlpull.org}),
which provides the underlying handling of XAS.  The basic type in the
API is the \path{fuegocore.util.xas.Event}, a small object with a type
tag.  These \path{Event} objects are collected into objects
implementing the \path{fuegocore.util.xas.EventSequence} interface,
which symbolizes an XML document or a fragment of such.

There are three different implementations of the \path{EventSequence}
interface.  The \path{fuegocore.util.xas.EventList} class contains
methods to insert individual events in the style of the modifying
methods of the \path{java.util.List} interface.  The
\path{fuegocore.util.xas.EventStream} class wraps a
\path{fuegocore.util.xas.TypedXmlParser} class to provide access to a
parsable byte sequence as a XAS \path{EventSequence}.  Finally, the
\path{fuegocore.util.xas.EventSerializer} class implements the
\path{fuegocore.util.xas.TypedXmlSerializer} interface to provide the
possibility of collecting an XML document being output into an
\path{EventSequence}.

Higher level classes wrap these to provide more sophisticated handling
of XML.  The \path{fuegocore.util.xas.XmlWriter} class provides
methods to output XML as complete elements instead of event by event.
The \path{fuegocore.util.xas.XmlReader} class is the counterpart of
this, providing a cursor into an \path{EventSequence} and methods to
read complete elements from this sequence.  The
\path{fuegocore.util.xas.TransformedEventStream} class is intended to
be subclassed by applications to implement a rule by which
subsequences of an \path{EventSequence} can be transformed into
others.  This transformed \texttt{Event\-Se\-quence} will be the one
provided to applications.  Examples of transformed event sequences are
\path{fuegocore.util.xas.CoalescedEventSequence}, which joins all
consecutive \path{CONTENT} events into one, and
\texttt{fuegocore.util.xas.Data\-Event\-Se\-quence}, which removes all
events except the tree structure and non\hyp{}whitespace content.

The XAS API is designed to be agnostic of the actual serialization
format used underneath.  Serializers and parsers are acquired through
the \path{fuegocore.util.xas.CodecFactory} interface.  Implementations
of this interface, on the other hand, are acquired through class
methods of the \path{fuegocore.util.xas.CodecIndustry} class using the
MIME type of the actual serialization format.  The \path{CodecFactory}
implementations are expected at application startup to register
themselves to the \path{CodecIndustry} under the MIME types that they
know how to handle.

The XAS API extends the XmlPull model to handle typed content.  In the
XAS model, the content of an element may be either a normal sequence
of other elements and \path{CONTENT} events or a single
\path{TYPED_CONTENT} event, consisting of an XML Schema type name and
an object.  By default the system handles the most common XML Schema
data types as well as \path{java.util.Vector},
\path{java.util.Hashtable}, and \path{EventSequence}.  Typed content
is encoded using a class of type
\path{fuegocore.util.xas.ContentEncoder} and decoded using a class of
type \path{fuegocore.util.xas.ContentDecoder}.

A \path{TypedXmlSerializer} will recognize the property
\path{fuegocore.util.xas.XasUtil.PROPERTY_CONTENT_CODEC}, the value of
which is the appropriate \texttt{Con\-tent\-Encoder} to use.  On the
parsing side, a view of an \texttt{Event\-Se\-quence} with all typed
content converted from the serialized form is provided by the
\path{fuegocore.util.xas.TypedEventStream} class, which takes a
\path{ContentDecoder} object for decoding the encoded forms.

Applications may add their own types to be recognized by implementing
the \path{fuegocore.util.xas.ContentCodecFactory} interface and its
associated \path{ContentEncoder} and \path{ContentDecoder} interfaces.
The preference for the latter two is to extend one of the abstract
classes \texttt{fuegocore.util.xas.Chained\-Con\-tent\-En\-cod\-er} or
\texttt{fuegocore.util.xas.ChainedContent\-De\-cod\-er}.  Other than
implementing these, they need to be registered through the
\path{CodecIndustry} class.

There is an experimental program called \path{codec} that constructs
these encoder and decoder implementations automatically with the
result that needed application code is lessened.  This program takes a
serialization format description in a language called \ac{ORL},
example files of which are in the directory
\path{code/sml/message/data} in the distribution directory.  Required
work are to extend the generated abstract decoder class to implement
object construction and to register the new factory to the
\path{CodecIndustry} class.

\section{The Xebu Serialization Format}
\label{sec:xebu-format}

The messaging system is able to use a variety of serialization formats
for XML data.  Normal textual XML is supported, and the others are
based on a binary format called Xebu, which is intended as an
efficient format for small XML documents with possibilities for
extension.  Each format is identified by a MIME type.  The serializers
and parsers are implemented in the package
\path{fuegocore.message.encoding}.

The messaging system uses these formats to convert SOAP messages into
a format for sending over the network.  Each format has an associated
implementation of the \path{CodecFactory} interface of the XAS API.
This factory produces objects implementing the
\path{TypedXmlSerializer} and \path{TypedXmlParser} interfaces.

The Xebu format is a concrete form of the abstract XAS data model.
Each XAS event is represented as a flagged token identifying the event
type followed by any components the event has.  Flags of the initial
token specify dynamic tokenization of strings in the event's
components.  Possibilities are to tokenize nothing, to tokenize only
names, and to tokenize names and values.

Xebu is also able to cache sequences of XAS events.  While the format
supports general caching, the current serializer will only cache
complete elements.  Such caching is marked by a special token that
indicates how many events backward are to be cached.  These cached
elements can later be used if, as is common, elements repeat across
messages.  Element caching is not available in FCME.

Further possibilities for improving the document sizes are to specify
statically some tokenizations beforehand and to specify omissions of
XAS events dynamically while serializing.  The former is done by
registering the property
\texttt{fue\-go\-core.message.encoding.XebuConstants.PROPERTY\_INITIAL\_CACHES}
with a value of an appropriate type
(\path{fuegocore.message.encoding.OutCache[]} for serializer and
\path{Object[][]} for parser) and the latter by registering the
property
\path{fuegocore.message.encoding.XebuConstants.PROPERTY_COA_MACHINE}
with a value of an appropriate type
(\path{fuegocore.message.encoding.EoaMachine} for serializer and
\path{fuegocore.message.encoding.DoaMachine} for parser).

Creating these pre-tokenizations and COA machines is not sensible to
do by hand.  Therefore the system provides a program called \path{coa}
that does this automatically from a schema defined in RELAX~NG compact
syntax.  This program automatically generates Java classes that
implement all the necessary functionality.

The Xebu formats with dynamic tokenization are supposed to be used
only when there is a clear sequencing of the serialized documents.
Therefore it is recommended that if Xebu is used for non-sequenced
data, e.g.\ for serializing files in a file system, dynamic
tokenization is turned off and only static pre\hyp{}tokenizations and COA
machines are used.

\section{Code Generators}

Applications will typically have their own specific data types that
they use and the syntax of the documents they generate typically
follows some schema.  To support this properly, the system provides
code generators that generate Java classes integratable into the
system from easily writable syntax descriptions.

Currently there are two such code generators.  The program \path{coa}
generates schema-aware serialization and parsing engines from a syntax
description and the program \path{codec} generates encoders and
decoders for data types.  Both programs have certain limitations on
what kinds of inputs they are capable of handling; currently there is
no precise definition of these limitations.

The program \path{coa} takes input files in RELAX~NG compact syntax
describing the XML document syntax.  It has various styles of output,
most of which were used during development for debugging purposes.
The principal way of invoking it is by \texttt{coa java <pkg>
  <files...>}, which generates three Java source files for each input
file: a \path{CachePair}, an \path{EoaMachine}, and a
\path{DoaMachine}; the names of the generated files are derived from
the name of the corresponding input file.  The generated files are
placed in the package \path{pkg}.

The \path{coa} program understands a very large subset of the RELAX~NG
language, but it supports a much smaller subset for code generation.
Interleaving is difficult to support in the current COA model, so
nothing is done with that.  Also, the current COA model is based
strictly on finite automata, so recursive elements, i.e.\ elements
that can contain themselves, are not supported at all.  The
best-tested collective features are groups, optional elements, and
repetitions.

To use the generated classes, an instance needs to be registered as a
property in the processor.  The \path{CachePair} class provides caches
for registration as the property
\path{XebuConstants.MESG_PROPERTY_INITIAL_CACHES}, and the two machine
classes are registered as the property
\path{XebuConstants.PROPERTY_COA_MACHINE} of the respective Xebu
serializer or parser.

The program \path{codec} is at a very preliminary stage of
development.  It understands the \ac{ORL} language, an example file of
which is provided in Figure~\ref{fig:orl-example} where \ac{ORL}
keywords are in bold.  The \texttt{package} declaration gives the Java
package of the defined types, the \texttt{codec-package} the Java
package where to put the generated classes, and the
\texttt{codec-name} a prefix for the names of the generated classes.

\begin{figure}[htb]
  \begin{center}
    \tt
    \begin{tabbing}
      \textbf{package} foo.types \\
      \textbf{codec-package} foo.codec \\
      \textbf{codec-name} foo \\
      \textbf{namespace} foo "http://www.foo.example/foo" \\
      \textbf{type} \= person \{ \\
      \> string name \\
      \> int age \\
      \> dateTime? birthday \\
      \}
    \end{tabbing}
  \end{center}
  \caption{An example \acs{ORL} file}
  \label{fig:orl-example}
\end{figure}

After the three initial definitions comes a sequence of
\texttt{namespace} and \texttt{type} declarations.  Each
\texttt{namespace} declaration defines a prefix for the namespace URI
(the URI must be in quotes) and places all following \texttt{type}
definitions into the declared namespace.  A \texttt{type} declaration
defines a name for the type; this will be used as both the XML Schema
type name in the current namespace as well as the Java class name with
the first letter capitalized.

The declaration of the contents of a type is similar to the
\texttt{struct} declaration in the C programming language.  Each
component consists of a pair of type and component name.  The type can
be a recognized XML Schema primitive type name or a type name defined
elsewhere in the \ac{ORL} file.

The Java class for which the serialization format is defined is
expected to have an accessor method for each component, i.e.\ in
Figure~\ref{fig:orl-example} the class \path{foo.types.Person} will
need to have methods \path{getName()}, \path{getAge()}, and
\path{getBirthday()} with result types \path{java.lang.String},
\path{java.lang.Integer}, and \path{java.util.Calendar}, respectively.
Of these, the last one may return \texttt{null} as it is declared
optional.

For the decoder side the generated decoder class is an abstract one
that needs to be subclassed into a class in the same package that has
the same name with the prefix \texttt{Abs} stripped.  This subclass
needs to implement a \texttt{build} method for each defined type that
takes as arguments the same types as the \texttt{get} methods return.
The return values of these \texttt{build} methods are of the
corresponding Java type.

Finally, the \path{codec} program generates a class subclassing the
\path{fuegocore.util.xas.ContentCodecFactory} abstract class.  An
object of this generated class needs to be registered with the XAS
system by invoking the \texttt{register\-Con\-tent\-Factory()} method
of the \path{CodecIndustry} class.

\section{Running Example Applications}
\label{sec:running_xml_hip}

The script \texttt{xml-serialize} serializes a sequence of XML
documents in the specified format.  The first argument to the script
is the name of the format and the rest are names of XML files.
Available type names are \texttt{xmlb} (for XML), \texttt{xmlz} (for
gzipped XML), and \texttt{none}, \texttt{item}, \texttt{data},
\texttt{elem}, \texttt{elit}, and \texttt{elid} for the various Xebu
formats.  The script outputs for each file an event sequence file
containing a representation of the XAS event sequence and another file
containing the selected serialized form.

\appendix

\section{The MIT License}
\label{app:mit-license}

Copyright \copyright{} 2003,2004 Helsinki Institute for Information
Technology

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

\end{document}
